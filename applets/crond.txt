The daemon runs with root privileges and uses the configures crontab-directory as its working directory. By default, this is "/var/spool/cron/crontabs".

If a file "cron.update" is placed in this directory, the first word from this file will be read which must be the name of an existing user. Then "cron.update" will be deleted and the crontab for this user will be re-read.

The crontabs are also read from the same directory and are files with the same name as the user they belong to, and must be owned by user root.

The crontab files are read using the normal BusyBox configuration file parser, and thus allow the usual comments and empty lines.

Otherwise, lines starting "SHELL=" and "MAILTO=" (only if configures) lines are explcitly handled; it remains unclear whether spaces around the "=" are also accepted, or whether other environment variables can be set as well.

Except for comment/assignment-lines, all crontab-lines are structured as 6 whitespace-separated fields on each line as follows:

* Minutes (0-59)

* Hours (0-23)

* Days (1-31)

* Months (1-12 or 3-letter lower case abbreviation)

* Days of Week (0 = sunday or 3-letter lower case abbreviation)

* The command to execute if the beforementioned fields match the current date and time

Except for the command field, all of the above fields support the following additional features (from highest to lowerst operator precedence):

"*" includes all possible values in the set of matching values for this field, i. e. this field will matches every date/time value.

"<from>-<to>" includes all values for the field in ascending order between <from> and <to> (both boundary values inclusive).

"<range>/<skip>" reduces the selected values from a range to its first value and then every <skipth>th value after that. For instance "3-9/2" selects only values 3, 5, 7 and 9 for inclusion.

"<entryN>,<entryN+1>" allows to specify multiple value ranges (which may include skips) for the field which will all be included.

Using the above syntax, all value fields in a crontab line represent arrays of all possible values, where every array value represents a boolean whether this value will be selected or deselected for matching the current date/time.

If the values representing the current/date time matches for all fields of a crontab entry line, the associated command will be run.

BusyBox crond holds all active crontabs in memory (about 160 Bytes per crontab entry for the fields and pointers plus the memory required for the command string itself); they are only read from disk when the process starts up or when an update of a user's crontab is enforced. In addition, the crontab directory is re-scanned every hour for changes. The same is done if the modification time of the crontab directory changes.

Besides containing the crontabs directory, the cron spool directory (defaults to /var/spool/cron) itself is not used for anything, except that it will be used as the current directory for cron jobs for which chdir $HOME does not work for some reason.

Whether the "cron.update"-mechanism is used to enforce reloading a crontab or whether the mtime of the crontab directory triggers reading new or updating existing crontabs, both mechanisms will only take effect the next time the crond daemin awakes. It does this every minute, and there is no way (such as SIGHUP) to make it reread crontabs immediately. However, there should be little trouble due to this, because cron jobs have only minute-resolution anyway.

When the daemon starts or the mtime of the crontab directory is changed, it is "scanned". This means that every directory entry is read, and must be a valid crontab file, except possible for "cron.update" which may exist (and will then be deleted and ignored otherwise by the scanning process).

When a cron job is run, the following environment variables will be set up explicitly:

HOME, LOGNAME, USER, SHELL.

In addition, exported shell variables (such as PATH) will be inherited normally.

SHELL is initially set to /bin/sh, and LOGNAME and HOME are set from the /etc/passwd line of the crontab's owner. (USER is set to the same as LOGNAME.)

Also, "SHELL" and "MAILTO" may be set/overriden from within the cron job itself via assignment statements in the affected user's crontab.

Note that SHELL is *not* taken from the user's /etc/passwd entry!

The command to be executed by the cron job is passed to the effective $SHELL and passed as a single argument following the shell's "-c" option. Normally, $SHELL will not be a login-shell, i. e. ~/.profile will not be read.

If I understood the code correctly, SHELL and MAILTO may be redefined multiple times within a crontab files, and the values effect the lines following it before the next change. Therefore, different SHELL and MAILTo values can be used in a single crontab, at least in the current implementation.

Finally, crond will impersonate the crontab's users when actually running the command, dropping it's elevated privileges (after forking, of course).

The current directory where the command will be started will be its HOME, or the cron spool directory as a fallback if changing the current directory to HOME that does not work.

If MAILTO is enabled, "sendmail -ti" will be run for mailing the cron job's output.

"-t": The -t command-line switch causes sendmail to gather its list of recipients from the message's header in addition to gathering them from its command line. When this switch is specified, sendmail gathers recipient names from the To:, Cc:, and Bcc: header lines. It also gathers recipient names from its command line if any were listed there. Duplicates are discarded, and the message is delivered to all that remain.

"-i": Sets the IgnoreDots option to true. The IgnoreDots (i) option tells sendmail to treat any line that contains only a single period as ordinary text, not as an end-of-file indicator.

crond runs "sendmail" as an external command. Note that while BusyBox provides an implementation of sendmail, it can only send mail to an SMTP server, and is incapable of delivering mail locally to a user on the same machine.

Verifying operation:

When running

$ crond -f -d0

crond runs in the foreground and should immediately report all found cron jobs to standard error.

If all jobs have been detected and parsed correctly, the setup works and the daemon can be run in the background, logging to syslog then.
